# 1. x86아키텍쳐 cpu 레지스터 종류, 역할
https://blog.naver.com/dkdlelgksthf/221175102460

## 1.1 you know register keyword in C? What is it?
**register**
```
register int num1 = 10;         
int num2 = 20;

/* assembly
   0x00000000000005fa <+0>:     push   rbp
   0x00000000000005fb <+1>:     mov    rbp,rsp
   0x00000000000005fe <+4>:     mov    DWORD PTR [rbp-0x4],0x14     ; num2 = 10;
   0x0000000000000605 <+11>:    mov    eax,0x0
   0x000000000000060a <+16>:    pop    rbp
   0x000000000000060b <+17>:    ret
*/

// num1은 메모리에 저장되는게 아니라 cpu의 레지스터에 저장되므로 disassem해도 보이지 않는다.
```

반복문 같은곳에서 효율이 좋다. (register변수는 접근이 빠르니까)
# 2. 스택프레임과 함수 프롤로그 에필로그 이해
우리가 코딩할때 함수의 몸체에 코딩을 하게 된다.
거기서 생성되고 삭제되는 변수들은 스택 메모리에 올라간다.
그럼 지역변수가 언제 사라질까? 이에 대한 답은 스택 메모리가 끝날때 사라진다. 정확히 말하면 덮어씌어진다.
스택 메모리를 끝낼려면 스택 메모리를 만들어야한다. 만들어진 스택 메모리를 스택 프레임이라고 한다.

함수가 호출될 때 마다 새로운 스택프레임이 생성된다.
a 변수를 만들고 b 변수도 만들고 func() 함수를 호출하면 func() 함수에 대한 스택프레임이 새로 생성된다. 그리고 func() 함수 몸체에 작성된 내용들이 모두 실행되고 나면 func() 함수의 스택 프레임을 메모리에서 없어버리고(정확히는 덮어씌우는 개념) func() 함수를 호출한 스택프레임으로 돌아가게 된다.

이를 정리하면 아래와 같은 루틴이 완성된다.
> 임의의 함수를 실행 -> 새로운 스택프레임 생성 -> 어떤 함수를 만남 -> 어떤 함수에 대한 스택프레임 생성 -> 어떤 함수가 끝나면 어떤 함수에 대한 스택프레임을 정리 -> 어떤 함수를 호출한 함수로 돌아옴


main함수의 구조를 보자

```
int main()/*함수 선언*/{ 
    /* 함수 
       몸체*/
    return 0;   /* 함수 종료 */
}
```
이 코드를 어셈블리어로 보면 아래와 같다.

```
   0x00000000000005fa <+0>:     push   rbp      
   0x00000000000005fb <+1>:     mov    rbp,rsp
   0x00000000000005fe <+4>:     mov    eax,0x0  ; 아무것도아님. eax 레지스터 초기화
   0x0000000000000603 <+9>:     pop    rbp
   0x0000000000000604 <+10>:    ret
```
하나씩 살펴보자
> Note: x86(32bit)에서 레지스터는 ebp, esp, eax 등 e가 먼저 붙지만 x64(64bit)에서 레지스터는 rbp, rsp, rax 등 r이 붙는다.


* rbp : 스택프레임의 시작점을 가리키는 레지스터 
* rsp : 스택프레임의 꼭대기를 가리키는 레지스터 

**0x00000000000005fa <+0>:     push   rbp        ; 스택 프레임 생성**

**0x00000000000005fb <+1>:     mov    rbp,rsp ; rsp의 위치를 rbp로 옮김**

위 2개 instruction이 함수 프롤로그이다. (웹툰같은데서 시작할때 프롤로그를 생각해보자)

**0x0000000000000603 <+9>:     pop    rbp**

**0x0000000000000604 <+10>:    ret** ; ret은 어떤 명령어가 축약된것이다. 찾아보자

위 2개 어셈블리 instruction이 함수 에필로그이다. (웹튼같은데서 완결난 뒤 에필로그를 생각해보자)


# 3. 함수호출규약 이해
함수는 뭔지 안다. 호출규약? 이것은 함수를 호출할때 어떠한 약속이 있다는 의미가 아닐까?
x86 아키텍쳐에서는 3가지 함수호출규약이 있다.
1. __cdecl
    + C/C++에서 함수호출규약을 지정하지 않으면 암묵적으로 지정되는 호출규약이 __cdecl이다. 
    + 이 호출규약을 사용하는 함수는 호출한 함수가 스택프레임을 정리한다.
    + 함수의 인자를 전달하는 순서는 오른쪽부터 순서대로 전달한다.
2. __stdcall
    + Win32API에서 사용된다.
    + 호출된 함수가 스택프레임을 정리한다.
    + 함수의 인자를 전달하는 순서는 오른쪽부터 순서대로 전달한다.
3. __fastcall
    + 이름부터 속도가 빨라보인다.
    + 인자가 레지스터 변수로 들어간다.
    + 왼쪽부터 전달하며 일정 갯수 이상의 인자는 스택으로 전달한다.(레지스터가 부족해서)
    + 호출된 함수가 스택프레임을 정리한다.

```
void __cdecl func(int a,int b);
void __fastcall func2(int a,int b,double c);
/* 생략 */
// 컴파일할때 특정 옵션을 줘야하나보다.
```

# 4. CPU caching
cpu에는 캐쉬 메모리라고 작은 메모리가 있다. 이 메모리는 자주 사용하는 명령을 복사해놓고 필요할때 사용하는 메모리다. 그럼 캐쉬를 겁나 크게 만들면 좋은거 아니냐고 생각할 수 있는데 비싸니까 작은거다.
## 4.1 캐싱이 사용될만한 적절한 예시 2개
1. 100만번 반복문 루틴에서 sum += 1; 이라는 코드가 있으면 이 코드를 캐쉬에 집어넣게 되면 성능 향상을 예상할 수 있다.
2. 자주 사용되는 함수를 캐쉬에 집어넣어도 성능 향상을 기대할 수 있다.